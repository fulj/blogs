JVM的主要组成部分及其作用
---
- 堆 栈 方法区 程序计数器 类加载子系统 本地库接口 本地方法库
- JVM包含两个子系统和两个组件，两个子系统为Class Loader（类装载）、Execution engine（执行引擎）；两个组件为Runtime data area（运行时数据区）、Native Interface（本地接口）。
- Class Loader：根据给定的全限定类名来装载class文件到Runtime data area中的method area
- Execution engine（执行引擎）：执行classes中的指令
- Native Interface（本地接口）：与native libraries交互，是其他编程语言交互的接口。
- Runtime data area（运行时数据区域）：这就是我们常说的JVM的内存。

作用：首先通过编译器把java代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，放在运行时数据区（Runtime data area）的方法区内，而字节码文件指示JVM的一套之灵气规范，并不能直接交给底层操作系统去执行，因此要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由CPU去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。

类加载指的是将.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后再堆区创建一个 class对象，用来封装类在方法区内的数据结构 
运行时数据区
---
程序计数器（Program Counter Register）：多线程 线程私有 字节码解析器通过这个值，来取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器完成。

java虚拟机栈（java virtual machine stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息

本地方法栈（native method stack）：为虚拟机调用native方法服务

java 堆（java heap）：Java虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；

方法区：用于存储被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据

深拷贝和浅拷贝
---
浅拷贝（shallowCopy）：只是增加了一个指针指向已存在的内存地址

深拷贝（deepCopy）增加了一个指针并且申请了一个新的内存地址，使这个增加的指针指向这个新的内存

堆栈的区别
---
#### 物理地址
堆的物理地址分配对象是不连续的，所以GC的时候考虑到不连续的分配，所以有各种算法，标记消除，复制，标记压缩，标记整理，分代（新生代使用复制，老年代使用标记压缩）

栈先进后出，物理地址分配是连续的，性能快。
#### 内存分别
堆因为是不连续的所以是运行期确认的，大小不固定，堆大小远远大于栈

栈是连续的内存地址编译器就确认，大小是固定的
#### 存放的内容
堆存放的对象的实例和数组。关注的是数据的存储

栈存放的是局部变量，操作数栈，返回结果，关注的是程序方法的执行

静态变量存放在方法区， 静态的对象还是放在堆

new指令
---
1. 检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞”方式分配内存；如果不规整，从空闲列表中分配，考虑到并发也有两种方式：CAS同步处理，或者本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）然后内存空间初始化操作，接着是做一些必要的对象设置（元信息、哈希吗。。。）最后执行init方法。

选择哪种分配方式是由java堆是否规整来决定的，而java堆是否规整又由所采用的垃圾收集器是否带有压缩功能决定。


处理并发安全问题
---
- 对象分配内存空间的动作进行同步处理（采用CAS+失败重试来保障更新操作的原子性）
- TLAB 每个线程在java堆中预先分配的一小块内存，只有TLAB用完分配新的TLAB时才需要同步锁 通过-XX参数来设定虚拟机是否使用TLAB

对象的访问定位
---
- 指针：指向对象
- 句柄：指向指针的指针，维护着对象的指针，句柄不直接指向对象，而指向对象的指针

HotSpot采用的是指针方式

Java会存在内存泄露吗
---
虽然Java有GC垃圾回收机制，但是一些资源不及时释放，导致一些长生命周期的对象一直引用这一些端声明周期的对象，还是会存在内存泄露的。

简述Java垃圾回收机制
---
Java中，程序员不需要显式的去释放一个对象的内存，JVM中有一个垃圾回收线程，它是低优先级的，正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描哪些没有被任何引用的对象，将他们添加到要回收的集合中，进行回收。

垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收
---
GC采用有向图的方式记录和管理堆（head）中的所有对象。通过这种方式确定哪些对象是“可达的”哪些对象是“不可达”

JVM 中永久代中会发生垃圾回收吗
垃圾回收一般不会发生在永久代，如果永久代满了或者是超过了临界值，就会触发完全垃圾回收（Full GC）。正确的设置永久代大小对避免FULL GC是非常重要的原因。JAVA8中已经移除了永久代，新加一个叫元数据区的native内存区。

说一下JVM有哪些垃圾回收算法
---
- 标记-清楚：效率不高无法清除垃圾碎片
- 复制算法：内存使用率不高，只有原来的一半
- 标记整理算法：标记无用对象，让所有的对象都向一端移动，然后直接清除掉边界以外的内存
- 分代算法：根据对象存活周期分为新生代和老年代，新生代采用复制算法，老年代采用标记整理算法

垃圾回收器
G1



> 什么是软引用什么是强引用
>

