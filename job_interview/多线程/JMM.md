Java线程之间的通信对程序员完全透明，本章4大部分：Java内存模型的基础、Java内存模型的顺序一致性、同步原语、Java内存模型的设计 

重排序与顺序一致性内存模型

处理器内存模型和顺序一致性内存模型的关系

## Java内存模型的基础
并发编程中两个关键问题：线程之间如何通信以及线程之间如何同步

通信：共享内存和消息传递

共享内存的并发模型

- 通信：线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。
- 同步：显式同步程序员必须制定某个方法或某段代码需要在线程之间互斥执行


消息传递的并发模型
- 通信：显式发送消息进行通信
- 同步：由于消息的发送必须在消息接收之前，因此同步式隐式进行的

java采用的是共享内存模型

Java内存模型的抽象结构
---
- 所有实例域、静态域、数组元素都存储在堆内存中，称为共享变量
- 局部变量、方法定义参数、异常处理参数不会在线程中共享，不存在可见性问题，也不受内存模型的影响

JMM决定一个线程共享变量的写入何时对另一个线程可见，定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中（Main Memory），某个线程有一个私有的本地内存（Local Memory）本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他硬件和编译器优化。

如果线程A、B之间要通信的话，必须经历2个步骤
- 线程A把本地内存A中更新过的共享变量刷新到主内存中去。
- 线程B到主内存中去读取线程A之前已更新过的共享变量
- JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。

从源代码到指令序列的重排序
---
- 编译器优化的重排序。在不改变单线程语义的前提先，可以重新安排语句执行顺序。
- 指令级并行的重排序。处理器可以改变语句对应机器指令的执行顺序（现代处理器（Instruction-Level Parallelism,ILP 多指令重叠执行）
- 内存系统的重排序。由于处理器使用缓存和读写缓冲区，使得加载和存储操作看上去可能是乱序执行

源代码->编译器优化重排序->指令级并行重排序->内存系统重排序->最终执行的指令序列

1. 对于编译器重排序JMM可以禁止特定类型的编译器重排序
2. 对于处理器重排序，JMM要求Java编译器生成指令序列的时候，插入特定类型的内存屏障(Memory Barriers, Intel 称之为Memory Fence)

happens-before
---
JSR-133使用 happens-before的概念来阐述操作之间的内存可见性，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。两个操作可以是一个线程之内，可可以是在不同的线程之间。
- 程序顺序规则：一个线程中每个操作，happens-before于该线程中的任意后续操作
- 监视器锁规则：对于一个锁的解锁，happens-before于随后对这个锁的加锁。
- volatile变量规则：对于一个volatile域的写，happens-before于任意后续对这个volatile域的读
- 传递性：如果A happens-before B，且B happens-before C，那么 A happens-before C。

happens-before关系，并不意味着一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作对后一个操作可见。

重排序
---
编译器和处理器为了优化程序性能对指令序列进行重新排序的一种手段

# Java 并发编程基础
线程的状态
| 状态名       | 说明            |
|--------------|-----------------|
| NEW          | 还没调用start() |
| RUNNABLE     | 运行中          |
| BLOCKED      | 阻塞            |
| WAITING      | 等待状态        |
| TIME_WAITING | 超时等待状态    |
| TERMINATED   | 终止状态        |

构造线程
---
在线程运行之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属线程组、线程优先级、是否Daemon线程等信息。

理解中断
---
中断可以理解为线程的一个标志位属性，它表示一个运行中的线程是否被其他线程进行了中断。中断好比其他线程对该线程打了招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。

线程通过检查自身是否中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断，也可调用Thread.interrupted()对当前线程的中断标识位进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧返回false

