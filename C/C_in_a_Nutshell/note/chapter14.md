# 多线程
C11标准以前，C开发人员必须依赖操作系统或相应链接库来实现并行。C11标准发布以后，使得C程序可便捷地实现并行。C11支持多线程执行（multithreaded execution）。为此C11定义了一个相应的内存模式（memery model），并且支持原子操作（atomic operation）。在C11标准下，对于多线程和原子操作的支持是可选的。如果支持C11标准的实现版本定义了宏_STDC_NO_THREADS_和_STDC_NO_ATOMICS_,则表示该实现版本不支持。

POSIX线程扩展（简称pthreads）该扩展是根据UNIX可移植操作系统接口（POSIX）--- 实现多线程编程的链接库。如果使用过该扩展，你会发现C11线程编程的接口在很多方面与POSIX标准类似。
## 线程
系统调度器为所有可运行的线程平均分配可用的CPU时间。通常，调度器是抢占式的：他会中断正在执行的线程，给CPU流出可用的短暂时间，并将CPU时间分配给其他线程使用一段时间。所以实际上多处理系统中，几个线程才可能真正的同时执行。

每个进程在内存中有自己的地址空间，并拥有独占的资源。进程中的线程共享一个地址空间。这使得切换线程比切换进程开销小。

然后，线程也有自己的资源：包括栈存储器和CPU寄存器。

对于一个进程，其内部线程可共享进程地址空间，如全局数据与静态数据。这意味着不同线程可以同时访问同一个内存单元，即发生了数据竞争（data race）或竞态条件（race condition）。为了防止data condition，程序员必须明确地同步不同线程的写操作或读写操作。
### 创建线程
头文件threads.h中，定义和声明了支持多线程的宏、类型和函数。所有直接与线程相关的标识符均以前缀thrd_作为开头。如thrd_t标识一个线程对象。  
线程创建
```
int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);
```
- func是一个指针，指向新线程需要被执行的函数
- void指针arg用于向函数传递参数
如果一个线程启动成功，函数thrd_create()将新线程写入一个对象进行标识，并通过参数thr指向该对象，然后返回宏值thread_success

thread_jion()用于确保一个线程已完成
```
int thrd_jion(thrd_t, int *result);
```
调用thread_join()的线程会被阻塞，直到通过thr标识的线程执行完成。

