# 输入和输出

程序必须能将数据写入文件或者物理输出设备，例如显示器打印机，并能够从文件输入设备读取数据。C标准库提供了许多函数让我们达到该目的，通常被称为IO链接库。除了这些链接库以外C语言本身并没有提供对输入输出的支持。  

所有输入输出基本函数、宏以及为其定义的类型，全部都在头文件stdio.h中进行声明。为wchar_t类型的宽字符对应声明的输入输出函数，包含在头文件wchar.h中。

作为传统标准IO函数基础上的补充，C11标准新增了许多新函数以支撑更加安全的编程，尤其是在复制数据的时候检查数据边界。这类函数名称都以**后缀_s结尾例如scanf_s()**   

可由用户选择是否支持这类函数。当给定C语言版本中定义宏__STDC_LIB_EXT1__, 就启用了这些函数

## 流
无论一次读写的是一个字符、字节、文本还是给定大小的数据区域，作为输入输出的各种文件和设备统一由逻辑数据流的形式展现。可以是文本流或二进制流，在某些系统上不区分两者。  
通过使用函数fopen() 或 tmfile() 打开一个文件就会建立一个新的流，fclose()函数关闭流。流就是一个传输通道，数据可以从运行环境流入程序中，或从程序流向运行环境。C语言对设备的处理机制和对文件的处理机制是一样的。

每个流都有一个**锁机制** ,当多线程访问同一个流的情况，IO库函数利用该锁保证同步性。当对一个流执行读写操作，或者查询和移动流文件位置指示器时，所有流IO函数会首先获得独占访问该流的权限。一旦操作完成，流的权限会被再次释放，以供其他线程访问。

### 文本流
文本流用来传输文本中的字符，文本被分割成多行。一行代表一个字符序列，以换行为该序列结尾。如果只包含一个换行符，那该文本行为空。最后一行可以有可以没有换行符，这由c语言的实现版本决定。
### 二进制流
二进制流式字节序列
### 文件
文件代表一系列的字节。函数fopen()将一个文件和一个流关联起来，并初始化一个类型为FILE的对象，该对象包含了控制该流的所有信息。这些信息包括**指向缓冲区的指针；文件位置指示器，它制定了获取文件的位置；以及只是错误和文件结尾情况的标志**   

fopen();freopen();tmpfile()等打开文件的函数会**会返回一个指向FILE对象的指针** 该FILE对象包含与被打开文件相关联的流。一旦打开文件就可以调用函数传递数据并对流进行处理。这些函数都把指向FILE对象的指针作为他们的参数之一。  
IO 链接库也包含了用于操作文件系统的函数，这些函数把文件名作为他们的参数之一。使用这些函数就不需要打开文件。  
- remove() 删除指定名称的文件
- rename() 重命名一个文件
```
if(rename("songs.dat","mysongs.dat")!=0)
	fprint(stderr, "Error renaming \"songs.dat\".\");
```
### 文件位置
与字符数组的元素一样，文件中每个字符在文件中都有一个确定的位置。流对象中的文件位置指示符（file position indicator）决定下一个要读写的字符的位置。  
打开文件准备读写时，文件指示符会指到文件开头，因此下一个带读取的位置就是0。如果以”append“模式打开文件，文件位置指示符会知道文件结尾。这种方式便于顺序处理文件内容。在文件内进行随机访问也是通过改变文件位置指示符实现的，通过函数fseek() fsetpos() rewind()可改变文件位置指示符，以实现在文件内随机访问。  
- 顺序读写
- append模式
- 随机读写
### 缓冲区
读写单个字符效率不高，缓冲区可以将许多字符集中起来，作为一个块在文件出入中传递。  
**全缓冲**   
&nbsp; &nbsp; 只有在缓冲区满时，缓冲区内的字符才会被转移  
**行缓冲**     
&nbsp;&nbsp; 只有当换行符被写入缓冲区，或者缓冲区满时，缓冲区内的字符才会被转移。当程序通过未缓冲的流请求输入，或者当行缓冲流做出输入请求，引起主环境读入字符时，流的缓冲区也会被写入写入文件中。  
**无缓冲**   
&nbsp;&nbsp; 字符会被晶块转移。  

也可调用**fflush()** 显式刷入文件。程序正常结束也会刷缓冲。
  
fopen() 打开一个普通文件时，新流是全缓冲的；打开交互设备，设备文件会被关联到行缓冲流。打开文件后，并且在第一次输入输出操作之前，可以使用函数setbuf()或setvbuf()来改变缓冲模式。
### 标准流
| FILE指针 | 通用名称     | 缓冲模式 |
|----------|--------------|----------|
| stdin    | 标准输入     | 行缓冲   |
| stdout   | 标准输出     | 行缓冲   |
| stderr   | 标准错误输出 | 无缓冲   |
## 打开和关闭文件
无论是新文件或是已有的文件，必须打开才可以向文件中写入数据，或修改其中内容。  
打开文件需要指定访问模式（access mode），表明计划对该文件进行的是读、写或读写结合。使用完关闭文件释放资源。
### 打开文件
- fopen()
- freopen()
- tmpfile()  
```
FILE *fopen(const char restrict *filename, const char * restrict mode);
```
filename字符串长度不得超过宏FILENAME_MAX中指定长度  
mode指定访问模式
```
FILE *freopen(const char * restrict filename,
			  const char * restrict mode,
			  FILE * restrict stream);

```

*test

该函数是将一个流重定向，freopen()不会建立新流，而是将文件与已有的流关联。通过第三个参数，之前与该流关联的文件被关闭。常用来重定向到标准流stdin stdout stderr


```
FILE *tmpfile(void);

```
*test
tmpfile()会建立一个新的临时文件，其文件名与所有已有文件名都不一样，然后打开该文件，进行二进制数据的读写操作，程序正常结束文件自动删除

以上三个函数返回一个指针。成功则指向已打开的流，失败返回空指针。

>传统标准函数不能确保独立文件访问权限，C11新增三个安全函数fopen_s() freopen_s tmpfile_s(),在操作系统支持的情况下课提供独立的访问权限
### 访问模式
第一个字符的三种形式：r w a 分别代表read write append  
+表示读写操作都可以  
b表示binary 二进制模式打开 如果没有b那就是字符串流  
> +的时候程序不可以在读写之间立即切换。在写操作之后必须调用函数fflush()或者定位函数(fseek() fsetpos() rewind()),然后才可以执行读操作。  
> 执行读操作之后必须调用定位函数然后才可以执行写操作。

```
#include <stdio.h>
#include <stdbool.h>
_Bool isReadWriteable(const char *filename)
{
	FILE *fp = fopen(filename, "r+");
	if(fp != NULL)
	{
		fclise(fp);
		return true;
	}
	else
		return false;	
}
```
## 读操作和写操作

一个被打开的流既可以用于处理字节符，也可用于处理宽字符。
### 字节导向流和宽字符导向流
除char类型之外，C语言也支持宽字符类型wchar_t,该类型足以表示实现版本所支持的宽展字符集中的所有字符。对应之下，有两组完整系列的函数可以进行字符和字符串的输入输出操作。分别称之为字节，字符IO函数。宽字符IO函数。宽字符io系列函数用来处理wchar_t类型的字符。每个流都有导向功能(orientation),决定使用哪一系列函数是合适的。换句话说导向功能决定使用宽字符IO函数还是字节字符IO函数  

在打开文件时，并未决定与其关联的流的导向。如果第一个访问操作使用的是字节字符IO函数，那么从该操作之后，该流属于字节导向。如果第一个访问操作使用的是宽字符IO函数，那么从该操作后该流属于宽字符导向。标准流stdin、stdout、stderr的导向也与上诉类似，在程序一开始，都没有被决定。  

任何时候可以调用dwide()来确定一个流的导向。在第一个IO操作之前可以使用fwide()设定一个流的导向。一旦流的导向被确定后，如想再改变它的导向，必须调用函数freopen()重新打开该流。

写入宽字符导向流的宽字符，会以多字节字符格式存储在与该流关联的文件中。读写函数会在wchar_t类型宽字符和多字节字符编码之间进行隐式地类型转换。该转换可能是状态性的，也就是说，多字节编码中的某个字节的值可能受前面控制字符的影响，控制字符会改变字符序列的位移状态（shift state)或转换状态(conversion state)。因此每个宽字符导向流都具有一个类型为mbstate_t的关联对象，该对象存储当前多字节转换状态。函数fgetpos() 和 fsetpos()用来获得和设定文件位置指示符的值，并可以针对给定的文件位置保存于恢复转换状态。

### 错误处理IO
IO函数提供了一些机制告知调用者函数执行中引发错误了，这些机制包括返回值、FILE对象中的错误标记和EOF标记，以及全局错误变量errno。究竟给定函数采用哪一种机制，18章再说。
#### 返回值和字符串标记
IO函数通常利用他们的返回值来指定所发生的错误。此外，如果发生读写错误，也会设定用来控制流的FILE对象中的错误标记。若想查询该标记，可调用函数ferror()。
```
(void)fputc('*', fp); //向流中写入一个星号
if(ferror(fp))
	fprintf(stderr, "error writing.\n");
```
而且，当读函数到达文件结尾时，就会设定流的EOF标记。可以通过调用函数feof()来查询该标记。
```
int i,c;
char buffer[1024];
/* ...使用流fp打开一个文件以用于读操作... */
i = 0;
while (i<1024 &&(c = fgetc(fp)) != EOF)
	buffer[i++] = (char)c;
if(i<1024 && !feof(fp))
	fprintf(stderr, "error reading.\n");
```


#### 错误变量errno
多个标准链接库函数支持更特殊的错误处理方式，该方式通过设置全局错误变量errno的值。可以设置errno的流处理函数包括ftell(),fgetpos()和fsetpos()。errno.h也为errno的可能取值定义了宏。
根据当前errno值，函数perror()将一条系统特定的错误信息输出到stderr流；
```
long pos = ftell(fp);//获取当前文件位置
if(pos<0L)
	perror("ftell");
```
函数perror()会输出它的字符串参数，后面接着冒号，然后是错误信息，最后是换行符GCC编译器版本下的函数perror()会输出下面的输出信息，已表示一个无效的FILE指针参数：
ftell(): Bad file descriptor  
### 无格式IO
标准库提供相关函数以支持无格式数据的读写，无格式数据可以是独立的位，字符串以及给定大小的内存区域。
### 读取字符
使用下面的函数从文件中读取字符
```
int fget(FILE *fp);
int getc(FILE *fp);
int getchar(void);
wint_t fgetwc(FILE *fp);
wint_t getwc(FILE *fp);
wint_t getwchar(void);
```
函数fget()从fp引用的输入流中读取一个字符。返回值是读入的字符，如果发生错误则返回EOF。宏getc()和函数fgetc()具有同样的功能。这个宏被经常使用，因为他比调用函数更快。然而，如果fp参数是一个具有副作用的表达式，那么应该用fgetc()而不要使用宏getc(),因为宏可能会多次计算参数。宏getchar()从标准输入中读取字符，他等同于getc(srdin).
fgetwc()、getwc和getwhar都是宽字符导向流对应的函数和宏。如果再多字节字符转换为宽字符时发生错误，这些函数都会把全局变量errno设定成值EILSEQ。
#### 放回一个字符
使用下面的函数可以将一个字符放回到它原来所在的流中：
```
int ungetc(int c, FILE *fp);
wint_t ungetwc(wint_t c,FILE *fp);
```
#### 写入字符
下面函数允许将单独的字符写入一个流中：
```
int fputc(int c, FILE *fp);
int putc(int c, FILE *fp);
int putchar(int c);
wint_t fputwc(wchar_ wc, FILE *fp);
wint_t putwc(wchar_t wc, FILE *fp);
wint_t putwchar(wchar_t wc);
```
下面示例将文件内容复制到一个已打开、用于写入数据的文件，该文件由fpOut引用的流关联。两个流都是字节导向的。
```
```
_Bool error = 0;
Int c;
rewind(fpIn); // 设置文件位置指示符至文件起始 
while((c=getc(fpIn)) != EOF)
	if(putc(c, fpOut) == EOF) // 将每个字符写入到输出流中
		{
			error=1;break;
		}
if(ferror(fpIn))
	error = 1;
```

#### 读取字符串
下面的函数可以从一个流中读取字符串：
```
char *fgets(char *buf, int n, FILE *fp);
wchar_t *fgetws(wchar_t *buf, int n, FILE *fp);
char *gets(char *buf);
char *gets_s(char *buf, size_t n);
```
函数fgets() 和 fgetws()可以从fp所引用的流中读取最多n-1个字节，将其放入buf所示地址的缓冲页中，并容灾后面添加一个空字符作为字符串终止符。如果该函数在读入最大数量的字符之前遇到一个换行符或者文件结尾，那么仅将当前锁读字符放入目标缓冲区。如果读到的换行符'\n'，换行符也会被存入缓冲区。
gets()从标准输入中读取一行文本，放到buf所示地址缓冲区中。该行文本末端的换行符在缓冲区会被空字符取代，一般采用fgets()取代gets()，因为gets()无法限制锁读取的字符的数量。C11标准停用了函数gets()，而增加了一个gets()的替代函数gets_s()