# 输入和输出

程序必须能将数据写入文件或者物理输出设备，例如显示器打印机，并能够从文件输入设备读取数据。C标准库提供了许多函数让我们达到该目的，通常被称为IO链接库。除了这些链接库以外C语言本身并没有提供对输入输出的支持。  

所有输入输出基本函数、宏以及为其定义的类型，全部都在头文件stdio.h中进行声明。为wchar_t类型的宽字符对应声明的输入输出函数，包含在头文件wchar.h中。

作为传统标准IO函数基础上的补充，C11标准新增了许多新函数以支撑更加安全的编程，尤其是在复制数据的时候检查数据边界。这类函数名称都以**后缀_s结尾例如scanf_s()**   

可由用户选择是否支持这类函数。当给定C语言版本中定义宏__STDC_LIB_EXT1__, 就启用了这些函数

## 流
无论一次读写的是一个字符、字节、文本还是给定大小的数据区域，作为输入输出的各种文件和设备统一由逻辑数据流的形式展现。可以是文本流或二进制流，在某些系统上不区分两者。  
通过使用函数fopen() 或 tmfile() 打开一个文件就会建立一个新的流，fclose()函数关闭流。流就是一个传输通道，数据可以从运行环境流入程序中，或从程序流向运行环境。C语言对设备的处理机制和对文件的处理机制是一样的。

每个流都有一个**锁机制** ,当多线程访问同一个流的情况，IO库函数利用该锁保证同步性。当对一个流执行读写操作，或者查询和移动流文件位置指示器时，所有流IO函数会首先获得独占访问该流的权限。一旦操作完成，流的权限会被再次释放，以供其他线程访问。

### 文本流
文本流用来传输文本中的字符，文本被分割成多行。一行代表一个字符序列，以换行为该序列结尾。如果只包含一个换行符，那该文本行为空。最后一行可以有可以没有换行符，这由c语言的实现版本决定。
### 二进制流
二进制流式字节序列
### 文件
文件代表一系列的字节。函数fopen()将一个文件和一个流关联起来，并初始化一个类型为FILE的对象，该对象包含了控制该流的所有信息。这些信息包括**指向缓冲区的指针；文件位置指示器，它制定了获取文件的位置；以及只是错误和文件结尾情况的标志**   

fopen();freopen();tmpfile()等打开文件的函数会**会返回一个指向FILE对象的指针** 该FILE对象包含与被打开文件相关联的流。一旦打开文件就可以调用函数传递数据并对流进行处理。这些函数都把指向FILE对象的指针作为他们的参数之一。  
IO 链接库也包含了用于操作文件系统的函数，这些函数把文件名作为他们的参数之一。使用这些函数就不需要打开文件。  
- remove() 删除指定名称的文件
- rename() 重命名一个文件
```
if(rename("songs.dat","mysongs.dat")!=0)
	fprint(stderr, "Error renaming \"songs.dat\".\");
```
### 文件位置
与字符数组的元素一样，文件中每个字符在文件中都有一个确定的位置。流对象中的文件位置指示符（file position indicator）决定下一个要读写的字符的位置。  
打开文件准备读写时，文件指示符会指到文件开头，因此下一个带读取的位置就是0。如果以”append“模式打开文件，文件位置指示符会知道文件结尾。这种方式便于顺序处理文件内容。在文件内进行随机访问也是通过改变文件位置指示符实现的，通过函数fseek() fsetpos() rewind()可改变文件位置指示符，以实现在文件内随机访问。  
- 顺序读写
- append模式
- 随机读写
### 缓冲区
读写单个字符效率不高，缓冲区可以将许多字符集中起来，作为一个块在文件出入中传递。  
**全缓冲**   
&nbsp; &nbsp; 只有在缓冲区满时，缓冲区内的字符才会被转移  
**行缓冲**     
&nbsp;&nbsp; 只有当换行符被写入缓冲区，或者缓冲区满时，缓冲区内的字符才会被转移。当程序通过未缓冲的流请求输入，或者当行缓冲流做出输入请求，引起主环境读入字符时，流的缓冲区也会被写入写入文件中。  
**无缓冲**   
&nbsp;&nbsp; 字符会被晶块转移。  

也可调用**fflush()** 显式刷入文件。程序正常结束也会刷缓冲。
  
fopen() 打开一个普通文件时，新流是全缓冲的；打开交互设备，设备文件会被关联到行缓冲流。打开文件后，并且在第一次输入输出操作之前，可以使用函数setbuf()或setvbuf()来改变缓冲模式。
### 标准流
| FILE指针 | 通用名称     | 缓冲模式 |
|----------|--------------|----------|
| stdin    | 标准输入     | 行缓冲   |
| stdout   | 标准输出     | 行缓冲   |
| stderr   | 标准错误输出 | 无缓冲   |
## 打开和关闭文件
无论是新文件或是已有的文件，必须打开才可以向文件中写入数据，或修改其中内容。  
打开文件需要指定访问模式（access mode），表明计划对该文件进行的是读、写或读写结合。使用完关闭文件释放资源。
### 打开文件
- fopen()
- freopen()
- tmpfile()  
```
FILE *fopen(const char restrict *filename, const char * restrict mode);
```
filename字符串长度不得超过宏FILENAME_MAX中指定长度  
mode指定访问模式
```
FILE *freopen(const char * restrict filename,
			  const char * restrict mode,
			  FILE * restrict stream);

```

*test

该函数是将一个流重定向，freopen()不会建立新流，而是将文件与已有的流关联。通过第三个参数，之前与该流关联的文件被关闭。常用来重定向到标准流stdin stdout stderr


```
FILE *tmpfile(void);

```
*test
tmpfile()会建立一个新的临时文件，其文件名与所有已有文件名都不一样，然后打开该文件，进行二进制数据的读写操作，程序正常结束文件自动删除

以上三个函数返回一个指针。成功则指向已打开的流，失败返回空指针。

>传统标准函数不能确保独立文件访问权限，C11新增三个安全函数fopen_s() freopen_s tmpfile_s(),在操作系统支持的情况下课提供独立的访问权限
### 访问模式
第一个字符的三种形式：r w a 分别代表read write append  
+表示读写操作都可以  
b表示binary 二进制模式打开 如果没有b那就是字符串流  
> +的时候程序不可以在读写之间立即切换。在写操作之后必须调用函数fflush()或者定位函数(fseek() fsetpos() rewind()),然后才可以执行读操作。  
> 执行读操作之后必须调用定位函数然后才可以执行写操作。

```
#include <stdio.h>
#include <stdbool.h>
_Bool isReadWriteable(const char *filename)
{
	FILE *fp = fopen(filename, "r+");
	if(fp != NULL)
	{
		fclise(fp);
		return true;
	}
	else
		return false;	
}
```
{

